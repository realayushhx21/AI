import java.util.*;

public class Main {

    static int A, B, T;
    static boolean[][] visited;
    static final int MAX_DEPTH = 4;   // depth limit

    static class State {
        int x, y;
        String action;
        int depth;   // how deep this state is in the search tree

        State(int x, int y, String action, int depth) {
            this.x = x;
            this.y = y;
            this.action = action;
            this.depth = depth;
        }

        String key() {
            return x + "," + y;
        }
    }

    // Check gcd feasibility
    static int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    // Generate next possible states (without depth, we’ll add it later)
    static List<State> getNextStates(State s) {
        List<State> list = new ArrayList<>();

        list.add(new State(A, s.y, "Fill Jug A", 0));
        list.add(new State(s.x, B, "Fill Jug B", 0));

        list.add(new State(0, s.y, "Empty Jug A", 0));
        list.add(new State(s.x, 0, "Empty Jug B", 0));

        int transferAB = Math.min(s.x, B - s.y);
        list.add(new State(s.x - transferAB, s.y + transferAB, "Pour Jug A → Jug B", 0));

        int transferBA = Math.min(s.y, A - s.x);
        list.add(new State(s.x + transferBA, s.y - transferBA, "Pour Jug B → Jug A", 0));

        return list;
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        System.out.print("Enter capacity of Jug A: ");
        A = sc.nextInt();

        System.out.print("Enter capacity of Jug B: ");
        B = sc.nextInt();

        System.out.print("Enter target amount: ");
        T = sc.nextInt();

        // Feasibility check (general, not depth-based)
        if (T > Math.max(A, B) || T % gcd(A, B) != 0) {
            System.out.println("No solution possible in general for these jugs.");
            System.out.println("Still running DLS up to depth " + MAX_DEPTH + "...\n");
        }

        visited = new boolean[A + 1][B + 1];

        Stack<State> stack = new Stack<>();
        List<State> solutionPath = new ArrayList<>();

        // start at (0,0) with depth 0
        stack.push(new State(0, 0, "Start", 0));

        boolean solutionFound = false;

        while (!stack.isEmpty()) {

            State curr = stack.pop();

            // skip if already visited at this state
            if (visited[curr.x][curr.y])
                continue;

            // depth limit check
            if (curr.depth > MAX_DEPTH)
                continue;

            visited[curr.x][curr.y] = true;
            solutionPath.add(curr);

            if (curr.x == T || curr.y == T) {
                solutionFound = true;
                break;
            }

            for (State next : getNextStates(curr)) {
                if (!visited[next.x][next.y]) {
                    // push with increased depth
                    stack.push(new State(next.x, next.y, next.action, curr.depth + 1));
                }
            }
        }

        if (!solutionFound) {
            System.out.println("\nNo solution found within depth " + MAX_DEPTH + ".");
            return;
        }

        System.out.println("\nSolution found using DLS (depth ≤ " + MAX_DEPTH + "):");
        State last = solutionPath.get(solutionPath.size() - 1);

        for (State st : solutionPath) {
            System.out.println(st.action + " -> (" + st.x + ", " + st.y + "), depth = " + st.depth);
        }

        System.out.println("\nTotal steps: " + (solutionPath.size() - 1));
        System.out.println("Final: (" + last.x + ", " + last.y + ") ✔");
        System.out.println("Target " + T + " liters achieved (within depth limit)!");
    }
}
