import java.util.*;

public class Main {

    static int[] goal = {1,2,3,4,5,6,7,8,0};

    static int h(int[] s) {
        int m = 0;
        for (int i = 0; i < 9; i++)
            if (s[i] != 0 && s[i] != goal[i]) m++;
        return m;
    }

    static void print(int[] s) {
        for (int i = 0; i < 9; i++) {
            if (s[i] == 0) System.out.print("_ ");
            else System.out.print(s[i] + " ");
            if ((i+1)%3 == 0) System.out.println();
        }
        System.out.println();
    }

    static String toStr(int[] s) {
        String k = "";
        for (int v : s) k += v;
        return k;
    }

    static int[] swp(int[] s, int i, int j) {
        int[] ns = s.clone();
        int t = ns[i]; ns[i] = ns[j]; ns[j] = t;
        return ns;
    }

    static class N {
        int[] s;   // state
        int g, f;  // cost and total cost
        N parent;  // parent pointer

        N(int[] s, int g, N p) {
            this.s = s;
            this.g = g;
            this.f = g + h(s);
            this.parent = p;
        }
    }

    public static void main(String[] args) {

        int[] st = {1,2,3,7,4,5,0,8,6};

        PriorityQueue<N> pq = new PriorityQueue<>((a,b) -> a.f - b.f);
        Set<String> vis = new HashSet<>();

        pq.add(new N(st, 0, null));

        int[] mv = {-3, +3, -1, +1};

        while (!pq.isEmpty()) {

            N cur = pq.poll();
            if (vis.contains(toStr(cur.s))) continue;
            vis.add(toStr(cur.s));

            System.out.println("g=" + cur.g + " h=" + h(cur.s) + " f=" + cur.f);
            print(cur.s);

            if (h(cur.s) == 0) {
                System.out.println("Goal Reached!\n\nSolution Path:");
                printPath(cur);
                break;
            }

            int blank = 0;
            for (int i = 0; i < 9; i++)
                if (cur.s[i] == 0) blank = i;

            int r = blank / 3, c = blank % 3;

            for (int m : mv) {
                int ni = blank + m;
                if (ni < 0 || ni >= 9) continue;
                if (m == -1 && c == 0) continue;
                if (m == 1 && c == 2) continue;

                int[] ns = swp(cur.s, blank, ni);
                pq.add(new N(ns, cur.g + 1, cur));
            }
        }
    }

    static void printPath(N n) {
        Stack<N> st = new Stack<>();
        while (n != null) {
            st.push(n);
            n = n.parent;
        }
        while (!st.isEmpty()) print(st.pop().s);
    }
}
