import java.util.*;

public class Main {

    static class State {
        int A, B;   // jug amounts
        int h;      // heuristic value
        State parent; // to trace full path

        State(int A, int B, int goal, State parent) {
            this.A = A;
            this.B = B;
            this.h = Math.min(Math.abs(A - goal), Math.abs(B - goal));
            this.parent = parent;
        }

        @Override
        public String toString() {
            return "(" + A + ", " + B + ")";
        }
    }

    public static void main(String[] args) {

        int capA = 4, capB = 3, goal = 2;

        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.h));
        HashSet<String> visited = new HashSet<>();

        State start = new State(0, 0, goal, null);
        pq.add(start);

        while (!pq.isEmpty()) {

            State curr = pq.poll();
            System.out.println("Visiting: " + curr + "  h=" + curr.h);

            if (curr.A == goal || curr.B == goal) {
                System.out.println("\n Goal reached at: " + curr + "\n");

                // Build path
                List<State> path = new ArrayList<>();
                while (curr != null) {
                    path.add(curr);
                    curr = curr.parent;
                }
                Collections.reverse(path);

                System.out.println(" Path taken:");
                for (State s : path) {
                    System.out.println("→ " + s);
                }

                System.out.println("\nTotal steps: " + (path.size() - 1));
                return;
            }

            String key = curr.A + "," + curr.B;
            if (visited.contains(key)) continue;
            visited.add(key);

            // Generate next states
            ArrayList<State> next = new ArrayList<>();

            next.add(new State(capA, curr.B, goal, curr));  // Fill A
            next.add(new State(curr.A, capB, goal, curr));  // Fill B
            next.add(new State(0, curr.B, goal, curr));     // Empty A
            next.add(new State(curr.A, 0, goal, curr));     // Empty B

            // Pour A → B
            int pourAB = Math.min(curr.A, capB - curr.B);
            next.add(new State(curr.A - pourAB, curr.B + pourAB, goal, curr));

            // Pour B → A
            int pourBA = Math.min(curr.B, capA - curr.A);
            next.add(new State(curr.A + pourBA, curr.B - pourBA, goal, curr));

            // Add valid moves to PQ
            for (State s : next) {
                String k = s.A + "," + s.B;
                if (!visited.contains(k))
                    pq.add(s);
            }
        }

        System.out.println(" No solution found.");
    }
}
